<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>
    // Set theme immediately to prevent flash
    (function() {
      const stored = localStorage.getItem('theme');
      if (stored) {
        document.documentElement.setAttribute('data-theme', stored);
      }
    })();
  </script>
   <link rel="stylesheet" href="/BioTutorials/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/BioTutorials/libs/highlight/styles/github.min.css" id="hljs-light">
<link rel="stylesheet" href="/BioTutorials/libs/highlight/styles/github-dark.min.css" id="hljs-dark" disabled>
<script>
  // Set initial highlight theme based on current theme
  (function() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark' ||
      (!document.documentElement.getAttribute('data-theme') &&
       window.matchMedia('(prefers-color-scheme: dark)').matches);
    document.getElementById('hljs-light').disabled = isDark;
    document.getElementById('hljs-dark').disabled = !isDark;
  })();
</script>
   
  <link rel="stylesheet" href="/BioTutorials/css/style.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap">

<link rel="icon" type="image/png" sizes="192x192" href="/BioTutorials/assets/favicon.png">
<link rel="shortcut icon" href="/BioTutorials/assets/favicon.ico">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/BioTutorials/assets/apple-touch-icon.png">


   <title>Problem 5: Computing GC Content - BioJulia</title>  
</head>
<body>
  <header class="site-header">
  <div class="header-content">
    <div class="header-left">
      <a href="https://biojulia.dev/BioTutorials" class="logo-link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 136.48101 51.472999" height="32" aria-label="BioJulia">
          <g id="bubble-helix">
            <circle cx="5.9792" cy="20.3" r="5.9792" fill="#945bb0"/>
            <circle cx="21.317" cy="39.5" r="4.9393" fill="#4266d5"/>
            <circle cx="16.378" cy="11.7" r="4.9393" fill="#c93d39"/>
            <circle cx="35.095" cy="35.9" r="5.9792" fill="#945bb0"/>
            <circle cx="47.184" cy="23.8" r="7.409" fill="#4266d5"/>
            <circle cx="28.986" cy="9.7" r="4.5494" fill="#3b972e"/>
            <circle cx="89.428" cy="46.5" r="4.9393" fill="#c93d39"/>
            <circle cx="71.62" cy="5.6" r="5.5892" fill="#945bb0"/>
            <circle cx="121.01" cy="15.5" r="5.5892" fill="#c93d39"/>
            <circle cx="59.662" cy="30.3" r="2.4697" fill="#4266d5"/>
            <circle cx="103.6" cy="19.9" r="3.2496" fill="#c93d39"/>
            <circle cx="123.61" cy="36.5" r="2.7296" fill="#4266d5"/>
            <circle cx="127.64" cy="5.2" r="3.8995" fill="#3b972e"/>
            <circle cx="132.58" cy="39.2" r="3.8995" fill="#945bb0"/>
            <circle cx="67.591" cy="37.4" r="3.3795" fill="#3b972e"/>
            <circle cx="95.017" cy="13.9" r="4.2894" fill="#4266d5"/>
            <circle cx="77.729" cy="42.9" r="3.8995" fill="#945bb0"/>
            <circle cx="102.56" cy="42.0" r="5.8492" fill="#4266d5"/>
            <circle cx="113.6" cy="28.8" r="6.7591" fill="#3b972e"/>
            <circle cx="57.582" cy="11.0" r="6.3691" fill="#c93d39"/>
            <circle cx="38.735" cy="14.8" r="3.3795" fill="#c93d39"/>
            <circle cx="84.618" cy="7.9" r="5.3293" fill="#3b972e"/>
          </g>
        </svg>
        <span>BioTutorials</span>
      </a>
    </div>
    <nav class="header-nav">
      <a href="/BioTutorials/">Tutorials</a>
      <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
        <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="5"></circle>
          <line x1="12" y1="1" x2="12" y2="3"></line>
          <line x1="12" y1="21" x2="12" y2="23"></line>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
          <line x1="1" y1="12" x2="3" y2="12"></line>
          <line x1="21" y1="12" x2="23" y2="12"></line>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
      </button>
    </nav>
  </div>
</header>

  <main class="franklin-content">

<div class="franklin-content" >
  <h1 id="problem_5_computing_gc_content" ><a href="#problem_5_computing_gc_content"> ðŸ§® Problem 5: Computing GC Content</a></h1><p>ðŸ¤” <a href="https://rosalind.info/problems/gc/">Problem link</a></p>
<blockquote><p><strong>The Problem</strong></p>
<p>The GC-content of a DNA string is given by the percentage of symbols
in the string that are 'C' or 'G'.
For example, the GC-content of "AGCTATAG" is 37.5%.
Note that the reverse complement of any DNA string has the same GC-content.</p>
<p>DNA strings must be labeled when they are consolidated into a database.
A commonly used method of string labeling is called FASTA format.
In this format, the string is introduced by a line that begins with '>',
followed by some labeling information.
Subsequent lines contain the string itself;
the first line to begin with '>' indicates the label of the next string.</p>
<p>In Rosalind's implementation,
a string in FASTA format will be labeled by the ID "Rosalind<em>xxxx",
where "xxxx" denotes a four-digit code between 0000 and 9999._Given</em>: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).</p>
<p><em>Return</em>: The ID of the string having the highest GC-content, followed by the GC-content of that string.
Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated.</p>
<p><strong>Sample Dataset</strong></p>
<pre><code class="julia">&gt;Rosalind_6404
CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC
TCCCACTAATAATTCTGAGG
&gt;Rosalind_5959
CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT
ATATCCATTTGTCAGCAGACACGC
&gt;Rosalind_0808
CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC
TGGGAACCTGCGGGCAGTAGGTGGAAT</code></pre>
<p><strong>Sample Output</strong></p>
<pre><code class="julia">Rosalind_0808
60.919540</code></pre>
</blockquote><p>There are really 3 parts of this problem.</p>
<ol>
<li>Parse the input, which is in a common biological format, FASTA</li>
<li>Calculate the GC content</li>
<li>Iterate through the input, keeping track of the largest GC content.</li>
</ol>
<p>Let's start with part 2, since it's quite similar to something we solved
in <a href="/BioTutorials/rosalind/01-dna">Problem 1: Counting DNA Nucleotides</a>.</p>
<h2 id="calculating_gc_content" ><a href="#calculating_gc_content"> Calculating GC content</a></h2><p>Just as when we were counting the frequency of each base,
here, we can calculate the GC content
by simply counting the number of G's or C's
and dividing that number by the total length of the sequence.</p>
<p>As a reminder, the <code>x-&gt; do stuff</code> notation is an "anonymous function",
which we're using as a "predicate" for the <code>count()</code> function.
That is, <code>count()</code> will return the sum of elements where the predicate
returns <code>true</code>.</p>
<pre><code class="julia">my_seq = &quot;AACCGGTTCT&quot;

function myGC(seq)
    gcs = count(base-&gt; base in ('G', 'C'), seq)
    return gcs / length(seq)
end

myGC(my_seq)  # 0.4</code></pre>
<p>A few things to note about this -
There's no validation of the input,
so this function will happily count the capital G's and C's
of any string:</p>
<pre><code class="julia">myGC(&quot;Goodbye, Cruel World!&quot;)  # 0.1904...</code></pre>
<p>But for now, this will do.</p>
<h3 id="biosequences_method" ><a href="#biosequences_method"> BioSequences method</a></h3><p>As with many of these problems,
there is built-in functionality in the <code>BioSequences.jl</code> package.
But before we get there,
let's take a look at another problem with being permissive
in our type signature up above:</p>
<pre><code class="julia">using BioSequences

bioseq = LongDNA&lbrace;2&rbrace;(my_seq)
myGC(bioseq)  # 0.0 -- wrong!</code></pre>
<p>What's going on here?
The definition above tries to count the <code>Char</code>s 'G' and 'C',
but when we iterate a <code>LongDNA</code>, we get back nucleotide types.
So none of them match, providing a count of \(0\).
We could modify the original function to look also for <code>DNA_C</code>,
<code>DNA_G</code>, <code>RNA_C</code>, and <code>RNA_G</code>,
or we can use the built-in predicate function <code>isGC()</code> from BioSequences,
which returns <code>true</code> if it encounters any G or C nucleotide.</p>
<pre><code class="julia">function myGC(seq::LongNuc) # this type matches LongDNA or LongRNA
    gcs = count(isGC, seq)
    return gcs / length(seq)
end

myGC(bioseq)  # 0.4</code></pre>
<p>Or, even more simply, there's already a <code>gc_content()</code> function in BioSequences.jl:</p>
<pre><code class="julia">gc_content(bioseq)  # 0.4</code></pre>
<h2 id="parsing_the_file" ><a href="#parsing_the_file"> Parsing the file</a></h2><p>We need to get this part done next.
We started talking about dealing with files in <a href="/BioTutorials/rosalind/04-fib">Problem 4</a>,
but let's go into a bit more detail.</p>
<p>When you want speed, there are a lot of tricks
to directly parse the bytes of the file one-by-one.
In fact, BioJulia developers created the package <code>Automa.jl</code>
to create fast parsers, and Jakob Nissen,
one of the co-administrators of BioJulia,
is currently working on modifications to Julia Base
to make dealing with files and byte streams even faster.</p>
<p>But for now, let's just do the easy thing,
and parse the file line-by-line using the <code>eachline()</code> function.
This function returns an iterator over the lines of the file,
one at a time,
that we can use in a <code>for</code> or <code>while</code> loop.</p>
<p>To begin with, let's write a function
that just goes through the whole file,
putting each sequence record into a <code>Vector</code>.</p>
<pre><code class="julia">function parse_fasta(buffer)
    records = [] # this is a Vector of type `Any`
    record_name = &quot;&quot;
    sequence = &quot;&quot;
    for line in eachline(buffer)
        if startswith(line, &quot;&gt;&quot;)
            !isempty(record_name) &amp;&amp; push!(records, (record_name, sequence))
            record_name = lstrip(line, '&gt;')
            sequence = &quot;&quot;
        else
            sequence *= line
        end
    end
    push!(records, (record_name, sequence))
    return records
end

fake_file = IOBuffer(&quot;&quot;&quot;
    &gt;Rosalind_6404
    CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC
    TCCCACTAATAATTCTGAGG
    &gt;Rosalind_5959
    CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT
    ATATCCATTTGTCAGCAGACACGC
    &gt;Rosalind_0808
    CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC
    TGGGAACCTGCGGGCAGTAGGTGGAAT
    &quot;&quot;&quot;
)

records = parse_fasta(fake_file)</code></pre>
<p>So we start with an empty <code>Vector</code> called <code>records</code>,
and empty <code>String</code>s representing the record name and sequence.
we need to assign these variables outside the "scope" of the loop,
otherwise they won't persist outside of it.</p>
<p>Then, we go through each line of the file,
checking if it starts with <code>&quot;&gt;&quot;</code>.
If it does, we push the current record into the <code>records</code> vector,
and reset the <code>record_name</code> and <code>sequence</code> variables.
If it doesn't, we append the line to the <code>sequence</code> variable
(in julia, we combine strings with the <code>*</code> operator).</p>
<p>The <code>isempty(record_name)</code> check is used
for the first record, to avoid pushing the initial empty strings,
and the final <code>push!(records, (record_name, sequence))</code>
is to deal with the final sequence,
since the loop will terminate without encountering a final <code>&gt;</code>.</p>
<blockquote><p><strong>Tip:</strong> Unlike a <code>String</code> or other data structure,
reading through an <code>IOBuffer</code> moves the "read head" â€”
there's a pointer to the end of the buffer after we've read through it.
If you need to use it again, reset the <code>IOBuffer</code> using the <code>seekstart()</code> function:</p>
<pre><code class="julia">seekstart(fake_file)
records = parse_fasta(fake_file)</code></pre>
</blockquote><p>At this stage, we could take our <code>records</code> Vector,
find the maximum gc entry, and then get that record.
As with many problems, there are a lot of ways to do this,
but we'll try the <code>findmax</code> function.
This function takes a function as the first argument,
and returns the "index" of the maximum value after using that function on the entry.</p>
<p>The "index" is an integer that we can use to access a particular entry
in a vector or other container.
In julia, the syntax for indexing is <code>container[index]</code>.
And notice that, since each of our <code>records</code> are themselves containers (<code>Tuple</code>s),
we can access the first element of each record (the identifier) using <code>record[1]</code>,
and the second element of each record (the sequence) using <code>record[2]</code>.</p>
<blockquote><p><strong>Tip:</strong> Julia uses one-based indexing, meaning that the first element of a container is at index 1,
not 0 as in some other languages like Python.</p>
</blockquote><pre><code class="julia">i = findmax(record -&gt; myGC(record[2]), records)[2]
top_gc = records[i][1] # the first index gets the record, and the `[1]` gets the identifier</code></pre>
<blockquote><p><strong>Tip: do-block syntax</strong></p>
<p>Many functions in Julia take a function as the first argument,
and sometimes the <code>-&gt;</code> anonymous function syntax is a bit annoying to use.
Instead, one can use the <code>do</code> block syntax.
This is a way to write a more complicated anonymous function,
eg one with multiple lines.</p>
<p>The structure of it is:</p>
<pre><code class="julia">some_func(iterator) do args # args is/are the argument(s) to the function
# function body
end</code></pre>
<p>In other words, our <code>findmax</code> function above could have been written as:</p>
<pre><code class="julia">i = findmax(records) do record
myGC(record[2])
end</code></pre>
</blockquote><h3 id="don't_store_the_whole_file_in_memory" ><a href="#don't_store_the_whole_file_in_memory"> Don't store the whole file in memory</a></h3><p>If you end up with a really large file,
storing every record in memory,
and then iterating over it a second time to calculate the GC content
may not be the best approach.
Instead, you can use a streaming approach,
where you read the file line by line,
and calculate the GC content on the fly.
This way, you only need to keep one record in memory at a time,
and you can find the record with the highest GC content without having to store all records in memory.</p>
<pre><code class="julia">function streaming_gc(buffer)
    max_gc = 0.0
    max_id = &quot;&quot;

    current_id = &quot;&quot;
    current_seq = &quot;&quot;
    for line in eachline(buffer)
        if startswith(line, &quot;&gt;&quot;)
            if length(current_seq) &gt; 0
                current_gc = myGC(current_seq)
                if current_gc &gt; max_gc
                    max_gc = current_gc
                    max_id = current_id
                end
            end
            current_id = lstrip(line, '&gt;')
            current_seq = &quot;&quot;
        else
            current_seq *= line
        end
    end
    if length(current_seq) &gt; 0
        current_gc = myGC(current_seq)
        if current_gc &gt; max_gc
            max_gc = current_gc
            max_id = current_id
        end
    end
    return max_id
end

seekstart(fake_file)
streaming_gc(fake_file)  # &quot;Rosalind_0808&quot;</code></pre>
<h3 id="biosequences_method__2" ><a href="#biosequences_method__2"> BioSequences method</a></h3><p>As you might imagine,
parsing FASTA files is something we do all the time,
so there's a package for that.
In julia, that package is called <a href="https://github.com/BioJulia/FASTX.jl"><code>FASTX.jl</code></a>
(there's also a "FASTQ" file format).</p>
<p>This package provides FASTA "readers" and "writers",
and return iterators that validate records and return
data structures containing the sequence identifiers and <code>BioSequence</code>s.</p>
<pre><code class="julia">using FASTX

function fastx_gc(buffer)
    max_gc = 0.0
    max_id = &quot;&quot;

    FASTAReader(buffer) do reader # see the &quot;tip&quot; above about do-blocks
        for record in reader
            gc = gc_content(sequence(LongDNA&lbrace;2&rbrace;, record))
            if gc &gt; max_gc
                max_gc = gc
                max_id = identifier(record)
            end
        end
    end
    return max_id, max_gc
end

seekstart(fake_file)
fastx_gc(fake_file)  # (&quot;Rosalind_0808&quot;, 0.6091954...)</code></pre>
<h2 id="reading_the_file" ><a href="#reading_the_file"> Reading the file</a></h2><p>So far, we've been dealing with an IOBuffer,
which is what we get when we open a file.
But to actually solve the rosalind problem,
we need to open a file on the disk.</p>
<p>In julia, we do this with the <code>open</code> function,
which takes a file path, and optionally a function to call with the file handle.
If we don't provide a function, we get an IOBuffer just as we've been using,
but we need to be sure to close it when we're done.</p>
<pre><code class="julia">function file_gc(filename)
    max_id, max_gc = open(fastx_gc, filename)
    println(max_id)
    println(100 * max_gc)
end

file_gc(&quot;rosalind_gc.txt&quot;)</code></pre>

  <footer class="page-foot">
  <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> BioJulia Developers
   Â· Last modified: 
  <br>
  Built with <a href="https://github.com/tlienart/Xranklin.jl">Xranklin.jl</a>
</footer>

</div>

  </main>
  
    <script src="/BioTutorials/libs/katex/katex.min.js"></script>
<script src="/BioTutorials/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

  
  
    <script src="/BioTutorials/libs/highlight/julia-custom.min.js"></script>
<script>
  // Configure highlight.js to recognize Xranklin's class format
  document.querySelectorAll('pre code').forEach((el) => {
    if (el.className && !el.className.startsWith('language-')) {
      el.classList.add('language-' + el.className.split(' ')[0]);
    }
  });
  hljs.highlightAll();
</script>

  
  <script>
    // Theme toggle functionality
    (function() {
      const toggle = document.getElementById('theme-toggle');
      if (!toggle) return;

      function getSystemTheme() {
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }

      function getCurrentTheme() {
        const stored = localStorage.getItem('theme');
        if (stored) return stored;
        return getSystemTheme();
      }

      function updateHighlightTheme(isDark) {
        const lightStyle = document.getElementById('hljs-light');
        const darkStyle = document.getElementById('hljs-dark');
        if (lightStyle && darkStyle) {
          lightStyle.disabled = isDark;
          darkStyle.disabled = !isDark;
        }
      }

      toggle.addEventListener('click', function() {
        const current = getCurrentTheme();
        const next = current === 'dark' ? 'light' : 'dark';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
        updateHighlightTheme(next === 'dark');
      });

      // Listen for system theme changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
        if (!localStorage.getItem('theme')) {
          // Only update if user hasn't manually set a preference
          document.documentElement.removeAttribute('data-theme');
          updateHighlightTheme(e.matches);
        }
      });
    })();
  </script>
</body>
</html>
