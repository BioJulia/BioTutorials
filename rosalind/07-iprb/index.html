<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>
    // Set theme immediately to prevent flash
    (function() {
      const stored = localStorage.getItem('theme');
      if (stored) {
        document.documentElement.setAttribute('data-theme', stored);
      }
    })();
  </script>
   <link rel="stylesheet" href="/BioTutorials/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/BioTutorials/libs/highlight/styles/github.min.css" id="hljs-light">
<link rel="stylesheet" href="/BioTutorials/libs/highlight/styles/github-dark.min.css" id="hljs-dark" disabled>
<script>
  // Set initial highlight theme based on current theme
  (function() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark' ||
      (!document.documentElement.getAttribute('data-theme') &&
       window.matchMedia('(prefers-color-scheme: dark)').matches);
    document.getElementById('hljs-light').disabled = isDark;
    document.getElementById('hljs-dark').disabled = !isDark;
  })();
</script>
   
  <link rel="stylesheet" href="/BioTutorials/css/style.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap">

<link rel="icon" type="image/png" sizes="192x192" href="/BioTutorials/assets/favicon.png">
<link rel="shortcut icon" href="/BioTutorials/assets/favicon.ico">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/BioTutorials/assets/apple-touch-icon.png">


   <title>Mendel's First Law - BioJulia</title>  
</head>
<body>
  <header class="site-header">
  <div class="header-content">
    <div class="header-left">
      <a href="https://biojulia.dev/BioTutorials" class="logo-link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 136.48101 51.472999" height="32" aria-label="BioJulia">
          <g id="bubble-helix">
            <circle cx="5.9792" cy="20.3" r="5.9792" fill="#945bb0"/>
            <circle cx="21.317" cy="39.5" r="4.9393" fill="#4266d5"/>
            <circle cx="16.378" cy="11.7" r="4.9393" fill="#c93d39"/>
            <circle cx="35.095" cy="35.9" r="5.9792" fill="#945bb0"/>
            <circle cx="47.184" cy="23.8" r="7.409" fill="#4266d5"/>
            <circle cx="28.986" cy="9.7" r="4.5494" fill="#3b972e"/>
            <circle cx="89.428" cy="46.5" r="4.9393" fill="#c93d39"/>
            <circle cx="71.62" cy="5.6" r="5.5892" fill="#945bb0"/>
            <circle cx="121.01" cy="15.5" r="5.5892" fill="#c93d39"/>
            <circle cx="59.662" cy="30.3" r="2.4697" fill="#4266d5"/>
            <circle cx="103.6" cy="19.9" r="3.2496" fill="#c93d39"/>
            <circle cx="123.61" cy="36.5" r="2.7296" fill="#4266d5"/>
            <circle cx="127.64" cy="5.2" r="3.8995" fill="#3b972e"/>
            <circle cx="132.58" cy="39.2" r="3.8995" fill="#945bb0"/>
            <circle cx="67.591" cy="37.4" r="3.3795" fill="#3b972e"/>
            <circle cx="95.017" cy="13.9" r="4.2894" fill="#4266d5"/>
            <circle cx="77.729" cy="42.9" r="3.8995" fill="#945bb0"/>
            <circle cx="102.56" cy="42.0" r="5.8492" fill="#4266d5"/>
            <circle cx="113.6" cy="28.8" r="6.7591" fill="#3b972e"/>
            <circle cx="57.582" cy="11.0" r="6.3691" fill="#c93d39"/>
            <circle cx="38.735" cy="14.8" r="3.3795" fill="#c93d39"/>
            <circle cx="84.618" cy="7.9" r="5.3293" fill="#3b972e"/>
          </g>
        </svg>
        <span>BioTutorials</span>
      </a>
    </div>
    <nav class="header-nav">
      <a href="/BioTutorials/">Tutorials</a>
      <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
        <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="5"></circle>
          <line x1="12" y1="1" x2="12" y2="3"></line>
          <line x1="12" y1="21" x2="12" y2="23"></line>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
          <line x1="1" y1="12" x2="3" y2="12"></line>
          <line x1="21" y1="12" x2="23" y2="12"></line>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
      </button>
    </nav>
  </div>
</header>

  <main class="franklin-content">

<div class="franklin-content" >
  <h1 id="mendel's_first_law" ><a href="#mendel's_first_law"> Mendel's First Law</a></h1><p>ðŸ¤” <a href="https://rosalind.info/problems/iprb/">Problem link</a></p>
<p>!!! warning "The Problem"</p>
<p>    Probability is the mathematical study of randomly occurring phenomena. 
    We will model such a phenomenon with a random variable, 
    which is simply a variable that can take a number of different distinct outcomes 
    depending on the result of an underlying random process.</p>
<p>    For example, say that we have a bag containing 3 red balls and 2 blue balls. 
    If we let X represent the random variable corresponding to the color of a drawn ball,
    then the probability of each of the two outcomes is given by Pr(X=red)=35 and Pr(X=blue)=25.</p>
<p>    Random variables can be combined to yield new random variables. 
    Returning to the ball example, let Y model the color of a second ball drawn from the bag (without replacing the first ball). 
    The probability of Y being red depends on whether the first ball was red or blue. </p>
<p>    To represent all outcomes of X and Y, we therefore use a probability tree diagram. 
    This branching diagram represents all possible individual probabilities for X and Y, 
    with outcomes at the endpoints ("leaves") of the tree. 
    The probability of any outcome is given by the product of probabilities along the path from the beginning of the tree.</p>
<p>    An event is simply a collection of outcomes. 
    Because outcomes are distinct, the probability of an event can be written as the sum of the probabilities of its constituent outcomes. </p>
<p>    For our colored ball example, let A be the event "Y is blue."
    Pr(A) is equal to the sum of the probabilities of two different outcomes: 
    Pr(X=blue and Y=blue)+Pr(X=red and Y=blue), or 310+110=25.</p>
<p>    Given: </p>
<p>    Three positive integers k, m, and n, 
    representing a population containing k+m+n organisms: 
    k individuals are homozygous dominant for a factor, m are heterozygous, and n are homozygous recessive.</p>
<p>    Return: The probability that two randomly selected mating organisms will produce an individual possessing a dominant allele (and thus displaying the dominant phenotype). </p>
<p>    Assume that any two organisms can mate.</p>
<p>We will show two ways we can solve this problem: deriving an algorithm or using a statistical weighted probability approach. </p>
<h3 id="deriving_an_algorithm" ><a href="#deriving_an_algorithm"> Deriving an Algorithm</a></h3><p>Using the information above, we can derive an algorithm using the variables k, m, and n that will calculate the probability of a progeny possessing a dominant allele. </p>
<p>We could calculate the probability of a progeny having a dominant allele, 
but in this case, it is easier to calculate the likelihood of a progeny having the recessive phenotype.
This is a relatively rarer event, and the calculation will be less complicated. 
We just have to subtract this probability from 1 to get the overall likelihood of having a progeny with a dominant trait. </p>
<p>To demonstrate how to derive this algorithm, we can use H and h to signify dominant and recessive alleles, respectively.
Out of all the possible combinations, we will only get a progeny with a recessive trait in three situations: Hh x Hh, Hh x hh, and hh x hh. 
For all of these situations, we must calculate the probability of these mating combinations occurring (based on k, m, and n), 
as well as the probability of these events leading to a progeny with a recessive trait.</p>
<p>First, we must calculate the probability of picking the first and second mate.
For the combination Hh x Hh, this is \(\frac{m}{(k+m+n)}\) multiplied by \(\frac{(m-1)}{(k+m+n-1)}\).</p>
<p>Selecting the second Hh individual is equal to the number of Hh individuals left after 1 was already picked (m-1),
divided by the total individuals left in the population (k+m+n-1). 
A similar calculation is performed for the rest of the combinations. </p>
<p>It is important to note that the probability of selecting Hh x hh as a mating pair is \(\frac{2*m*n}{(k+m+n)(k+m+n-1)}\),
as there are two ways to choose this combination.
Hh x hh can be selected (where Hh is picked first), as well as hh x Hh. Order matters!</p>
<table class="">
<thead>
<th > Probability of combination occurring </th>
<th > Hh x Hh </th>
<th > Hh x hh </th>
<th > hh x hh </th>
</thead>
<tbody>
<tr>
<td > </td>
<td > \(\frac{m(m-1)}{(k+m+n)(k+m+n-1)}\) </td>
<td >  \(\frac{2*m*n}{(k+m+n)(k+m+n-1)}\)</td>
<td > \(\frac{n(n-1)}{(k+m+n)(k+m+n-1)}\)</td>
</tr>
</tbody>
</table>
<p><a href="br">br</a>
<a href="br">br</a></p>
<p>The probability of these combinations leading to a recessive trait can be calculated using Punnet Squares.</p>
<table class="">
<thead>
<th > Probability of recessive trait </th>
<th > Hh x Hh </th>
<th > Hh x hh </th>
<th > hh x hh </th>
</thead>
<tbody>
<tr>
<td > </td>
<td > 0.25 </td>
<td > 0.50 </td>
<td > 1 </td>
</tr>
</tbody>
</table>
<p><a href="br">br</a>
<a href="br">br</a></p>
<p>Now, we just have to sum the probability of each combination occurring by the probability of this combination leading to a recessive trait. </p>
<p>This leads to the following formula:</p>
<p>Pr(recessive trait) = 
\(\frac{m(m-1)}{(k+m+n)(k+m+n-1)}\) x 0.25 + \(\frac{m*n}{(k+m+n)(k+m+n-1)}\) + \(\frac{n(n-1)}{(k+m+n)(k+m+n-1)}\)</p>
<p>Therefore, the probability of selecting an individual with a <em>dominant</em> trait is 1 - Pr(recessive trait). </p>
<p>Now that we've derived this formula, let's turn this into code!</p>
<pre><code class="julia">function mendel(k,m,n)

    # denominator of the above fractions describing probability of different matches
    total = (k+m+n)*(k+m+n-1) 
    return 1-(
        (0.25*m*(m-1))/total + 
        m*n/total + 
        n*(n-1)/total)
end

mendel(2,2,2)</code></pre>
<p>Deriving and using this algorithm works.</p>
<p>However, it is also narrowly tailored to a specific problem. </p>
<p>What happens if we want to solve a more complicated problem or if there are additional requirements tacked on? </p>
<p>For example, what if we wanted to solve a question like "What's the probability of a heterozygous offspring?"</p>
<p>We would need to derive another algorithm for this similar, yet slightly different problem. </p>
<p>Algorithms work in certain cases, but also don't scale up if we add more constraints.</p>
<p>Another approach would be to use a statistics-based solution. </p>
<p>For instance, we can use a simulation that can broadly calculate the likelihood of a given offspring based on a set of given probabilities.</p>
<p>This solution is generic and can be used to ask more types of questions. </p>
<h3 id="simulation_method" ><a href="#simulation_method"> Simulation Method</a></h3><p>For this method, we will make a fake population that follows the given parameters k, m, and n. </p>
<p>Specifically, we can make a vector of 1's, 2's, and 3's, representing the HH, Hh, and hh genotypes, respectively.</p>
<p>In this vector, there will be k 1's, m 2's, and n 3's. </p>
<p>Next, we'll make another vector that stores the probabilities of there being a dominant phenotype given the parental genotypes.</p>
<p>This is calculated using Punnett Squares.</p>
<p>For example, if HH mates with either [HH, Hh, hh], the probability of a dominant phenotype is 100%, leading to a vector [1, 1, 1].</p>
<p>Now that these vectors have been created, we can begin the simulation.</p>
<p>First, we will sample from the population to approximate the ratio of dominant phenotypes. </p>
<p>For each iteration, we will randomly pick two mates from the population.</p>
<p>For example, 2 (Hh) and 3 (hh) is picked. </p>
<p>This will lead to a probability of a dominant allele = 0.5.</p>
<p>All of the probabilities will be accumulated throughout all of the simulations.</p>
<p>At the end of the simulation, we can divide the sum of the probabilities by the total number of simulations.</p>
<p>This will get us the approximated number of individuals with a dominant phenotype.</p>
<p>This method is unlikely to return exactly the same answer as the algorithm approach.</p>
<p>Sampling is random, so we will get slightly different results each time we run the simulation (unless we set a seed).</p>
<p>However, both methods will be very similar.</p>
<p>The standard error for the estimate decreases as the number of simulations gets very large.</p>
<p>The larger the number of iterations, the more likely that the final approximation will be similar both between simulations, as well as to the answer from the algorithm.</p>
<p>It is important to keep in mind that both the algorithm and statistical sampling approaches only provide approximations, as there will definitely be some unaccounted variation in a true biological population!</p>
<pre><code class="julia">using StatsBase

# Probability of dominant offspring given parent genotypes
# Index: offspring_prob[parent1, parent2]
# Genotypes: 1=HH, 2=Hh, 3=hh

ex_offspring_prob = [
        1.0   1.0   1.0;   # HH Ã— (HH, Hh, hh)
        1.0   0.75  0.5;   # Hh Ã— (HH, Hh, hh)
        1.0   0.5   0.0    # hh Ã— (HH, Hh, hh)
    ]

function mendel_sim(k, m, n, offspring_prob; iterations=100000)
    # Genotypes: 1=HH, 2=Hh, 3=hh
    population = [fill(1, k); fill(2, m); fill(3, n)]

    total_pop = k+m+n
    wts = [k/total_pop, m/total_pop, n/total_pop]

    # samples two mates from the vector [1,2,3] with probability weights given by wts

    # then sum the probability of each offspring having a dominant phenotype
    # sum across all simulations
    sum(1:iterations) do _
        (i,j) = sample([1,2,3], weights(wts), 2)
        offspring_prob[i,j]
    end / iterations
end

mendel_sim(2, 2, 2, ex_offspring_prob)</code></pre>
<p>In the function above, the user provides the parameter <code>offspring_prob</code>.   
If the user wanted to answer a slightly different question with different probability weights,  
all that would be needed is a different input vector. 
This allows the user to solve a wider variety of questions.</p>
<p>However, this function does assume that there are only 3 phenotypes, which limits the situations it can be applied towards.  </p>
<p>This solution returns a value closer to 0.75,   
while the first one returns a value close to 0.783.</p>

  <footer class="page-foot">
  <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> BioJulia Developers
   Â· Last modified: 
  <br>
  Built with <a href="https://github.com/tlienart/Xranklin.jl">Xranklin.jl</a>
</footer>

</div>

  </main>
  
    <script src="/BioTutorials/libs/katex/katex.min.js"></script>
<script src="/BioTutorials/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

  
  
    <script src="/BioTutorials/libs/highlight/julia-custom.min.js"></script>
<script>
  // Configure highlight.js to recognize Xranklin's class format
  document.querySelectorAll('pre code').forEach((el) => {
    if (el.className && !el.className.startsWith('language-')) {
      el.classList.add('language-' + el.className.split(' ')[0]);
    }
  });
  hljs.highlightAll();
</script>

  
  <script>
    // Theme toggle functionality
    (function() {
      const toggle = document.getElementById('theme-toggle');
      if (!toggle) return;

      function getSystemTheme() {
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }

      function getCurrentTheme() {
        const stored = localStorage.getItem('theme');
        if (stored) return stored;
        return getSystemTheme();
      }

      function updateHighlightTheme(isDark) {
        const lightStyle = document.getElementById('hljs-light');
        const darkStyle = document.getElementById('hljs-dark');
        if (lightStyle && darkStyle) {
          lightStyle.disabled = isDark;
          darkStyle.disabled = !isDark;
        }
      }

      toggle.addEventListener('click', function() {
        const current = getCurrentTheme();
        const next = current === 'dark' ? 'light' : 'dark';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
        updateHighlightTheme(next === 'dark');
      });

      // Listen for system theme changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
        if (!localStorage.getItem('theme')) {
          // Only update if user hasn't manually set a preference
          document.documentElement.removeAttribute('data-theme');
          updateHighlightTheme(e.matches);
        }
      });
    })();
  </script>
</body>
</html>
