import{_ as l,c as n,o as e,az as t,j as i,a}from"./chunks/framework.aIw77uuq.js";const E=JSON.parse('{"title":"ðŸ§® Computing GC content","description":"","frontmatter":{},"headers":[],"relativePath":"rosalind/05-gc.md","filePath":"rosalind/05-gc.md","lastUpdated":null}'),p={name:"rosalind/05-gc.md"},h={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},k={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.131ex",height:"1.557ex",role:"img",focusable:"false",viewBox:"0 -666 500 688","aria-hidden":"true"};function o(d,s,r,c,g,u){return e(),n("div",null,[s[20]||(s[20]=t(`<h1 id="Computing-GC-content" tabindex="-1">ðŸ§® Computing GC content <a class="header-anchor" href="#Computing-GC-content" aria-label="Permalink to &quot;ðŸ§® Computing GC content {#Computing-GC-content}&quot;">â€‹</a></h1><div class="warning custom-block"><p class="custom-block-title">The Problem</p><p>The GC-content of a DNA string is given by the percentage of symbols in the string that are &#39;C&#39; or &#39;G&#39;. For example, the GC-content of &quot;AGCTATAG&quot; is 37.5%. Note that the reverse complement of any DNA string has the same GC-content.</p><p>DNA strings must be labeled when they are consolidated into a database. A commonly used method of string labeling is called FASTA format. In this format, the string is introduced by a line that begins with &#39;&gt;&#39;, followed by some labeling information. Subsequent lines contain the string itself; the first line to begin with &#39;&gt;&#39; indicates the label of the next string.</p><p>In Rosalind&#39;s implementation, a string in FASTA format will be labeled by the ID &quot;Rosalind_xxxx&quot;, where &quot;xxxx&quot; denotes a four-digit code between 0000 and 9999.</p><p><em>Given</em>: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).</p><p><em>Return</em>: The ID of the string having the highest GC-content, followed by the GC-content of that string. Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated; please see the note on absolute error below.</p><p><strong>Sample Dataset</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt;Rosalind_6404</span></span>
<span class="line"><span>CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC</span></span>
<span class="line"><span>TCCCACTAATAATTCTGAGG</span></span>
<span class="line"><span>&gt;Rosalind_5959</span></span>
<span class="line"><span>CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT</span></span>
<span class="line"><span>ATATCCATTTGTCAGCAGACACGC</span></span>
<span class="line"><span>&gt;Rosalind_0808</span></span>
<span class="line"><span>CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC</span></span>
<span class="line"><span>TGGGAACCTGCGGGCAGTAGGTGGAAT</span></span></code></pre></div><p><strong>Sample Output</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Rosalind_0808</span></span>
<span class="line"><span>60.919540</span></span></code></pre></div></div><p>There are are really 3 parts of this problem.</p><ol><li><p>Parse the input, which is in a common biological format, FASTA</p></li><li><p>Calculate the GC content</p></li><li><p>Iterate through the input, keeping track of the largest GC content.</p></li></ol><p>Let&#39;s start with part 2, since it&#39;s quite similar to something we solved <a href="/BioTutorials/dev/rosalind/01-dna#Problem-1:-Counting-DNA-nucleotides">in the very first problem</a>.</p><h2 id="Calculating-GC-content" tabindex="-1">Calculating GC content <a class="header-anchor" href="#Calculating-GC-content" aria-label="Permalink to &quot;Calculating GC content {#Calculating-GC-content}&quot;">â€‹</a></h2><p>Just as when we were counting the frequency of each base, here, we can calculate the GC content by simply counting the number of G&#39;s or C&#39;s and dividing that number by the total length of the sequence.</p><p>As a reminder, the <code>x-&gt; do stuff</code> notation is an &quot;anonymous function&quot;, which we&#39;re using as a &quot;predicate&quot; for the <code>count()</code> function. That is, <code>count()</code> will return the sum of elements where the predicate returns <code>true</code>.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">my_seq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;AACCGGTTCT&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seq)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gcs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> base </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;G&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), seq)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gcs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seq)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(my_seq)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0.5</span></span></code></pre></div><p>A few things to note about this - There&#39;s no validation of the input, so this function will happily count the capital G&#39;s and C&#39;s of any string:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Goodbye, Cruel World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0.09523809523809523</span></span></code></pre></div><p>But for now, this will do.</p><h3 id="BioSequences-method" tabindex="-1">BioSequences method <a class="header-anchor" href="#BioSequences-method" aria-label="Permalink to &quot;BioSequences method {#BioSequences-method}&quot;">â€‹</a></h3><p>As with many of these problems, there is built-in functionality in the <code>BioSequences.jl</code> package. But before we get there, let&#39;s take a look at another problem with being permissive in our type signature up above:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BioSequences</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bioseq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LongDNA{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(my_seq)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bioseq)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0.0</span></span></code></pre></div>`,18)),i("p",null,[s[2]||(s[2]=a("What's going on here? The definition above tries to count the ")),s[3]||(s[3]=i("code",null,"Char",-1)),s[4]||(s[4]=a("s 'G' and 'C', but when we iterate a ")),s[5]||(s[5]=i("code",null,"LongDNA",-1)),s[6]||(s[6]=a(", we get back nucleotide types. So none of them match, providing a count of ")),i("mjx-container",h,[(e(),n("svg",k,s[0]||(s[0]=[i("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[i("g",{"data-mml-node":"math"},[i("g",{"data-mml-node":"mn"},[i("path",{"data-c":"30",d:"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z",style:{"stroke-width":"3"}})])])],-1)]))),s[1]||(s[1]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mn",null,"0")])],-1))]),s[7]||(s[7]=a(". We could modify the original function to look also for ")),s[8]||(s[8]=i("code",null,"DNA_C",-1)),s[9]||(s[9]=a(", ")),s[10]||(s[10]=i("code",null,"DNA_G",-1)),s[11]||(s[11]=a(", ")),s[12]||(s[12]=i("code",null,"RNA_C",-1)),s[13]||(s[13]=a(", and ")),s[14]||(s[14]=i("code",null,"RNA_G",-1)),s[15]||(s[15]=a(", or we can use the built-in predicate function ")),s[16]||(s[16]=i("code",null,"isGC()",-1)),s[17]||(s[17]=a(" from BioSequences, which returns ")),s[18]||(s[18]=i("code",null,"true",-1)),s[19]||(s[19]=a(" if it encounters any G or C nucleotide."))]),s[21]||(s[21]=t(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LongNuc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># this type matches LongDNA or LongRNA</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gcs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isGC, bioseq)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gcs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seq)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bioseq)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0.5</span></span></code></pre></div><p>Or, even more simply, there&#39;s already a <code>gc_content()</code> function in BioSequences.jl:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gc_content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bioseq)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0.5</span></span></code></pre></div><h2 id="Parsing-the-file" tabindex="-1">Parsing the file <a class="header-anchor" href="#Parsing-the-file" aria-label="Permalink to &quot;Parsing the file {#Parsing-the-file}&quot;">â€‹</a></h2><p>We need to get this part done next. We started talking about dealing with files in the <a href="/BioTutorials/dev/rosalind/04-fib#Rabbits-and-Recurrence-Relations">last problem</a>, but let&#39;s go into a bit more detail.</p><p>When you want speed, there are a lot of tricks to directly parse the bytes of the file one-by-one. In fact, BioJulia developers created the package <code>Automa.jl</code> to create fast parsers, and Jakob Nissen, one of the co-administrators of BioJulia, is currently working on modifications to Julia Base to make dealing with files and byte streams even faster.</p><p>But for now, let&#39;s just do the easy thing, and parse the file line-by-line using the <code>eachline()</code> function. This function returns an iterator over the lines of the file, one at a time, that we can use in a <code>for</code> or <code>while</code> loop.</p><p>To begin with, let&#39;s write a function that just goes through the whole file, putting each sequence record into a <code>Vector</code>.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parse_fasta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    records </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># this is a Vector of type \`Any\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    record_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sequence </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> line </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eachline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> startswith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(line, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            !</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isempty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(record_name) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(records, (record_name, sequence))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            record_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> lstrip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(line, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            sequence </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            sequence </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> line</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(records, (record_name, sequence))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> records</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fake_file </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> IOBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &gt;Rosalind_6404</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    TCCCACTAATAATTCTGAGG</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &gt;Rosalind_5959</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    ATATCCATTTGTCAGCAGACACGC</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &gt;Rosalind_0808</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    TGGGAACCTGCGGGCAGTAGGTGGAAT</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">records </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parse_fasta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fake_file)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>3-element Vector{Any}:</span></span>
<span class="line"><span> (&quot;Rosalind_6404&quot;, &quot;CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCCTCCCACTAATAATTCTGAGG&quot;)</span></span>
<span class="line"><span> (&quot;Rosalind_5959&quot;, &quot;CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCTATATCCATTTGTCAGCAGACACGC&quot;)</span></span>
<span class="line"><span> (&quot;Rosalind_0808&quot;, &quot;CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGACTGGGAACCTGCGGGCAGTAGGTGGAAT&quot;)</span></span></code></pre></div><p>So we start with an empty <code>Vector</code> called <code>records</code>, and empty <code>String</code>s representing the record name and sequence. we need to assign these variables outside the &quot;scope&quot; of the loop, otherwise they won&#39;t persist outside of it. We&#39;ll talk more about &quot;scope&quot; another time.</p><p>Then, we go through each line of the file, checking if it starts with <code>&quot;&gt;&quot;</code>. If it does, we push the current record into the <code>records</code> vector, and reset the <code>record_name</code> and <code>sequence</code> variables. If it doesn&#39;t, we append the line to the <code>sequence</code> variable (in julia, we combine strings with the <code>*</code> operator).</p><p>The <code>isempty(record_name)</code> check in the 7th line of the function is used for the first record, to avoid pushing the initial empty strings, and the final <code>push!(records, (record_name, sequence))</code> is to deal with the final sequence, since the loop will terminate without encountering a final <code>&gt;</code>.</p><div class="tip custom-block"><p class="custom-block-title">Our &#39;fake file&#39;</p><p>To show off how this works, we&#39;re using an <code>IOBuffer</code>, which in most cases works pretty similar to an open file buffer. One thing to keep in mind is that, unlike a <code>String</code> or other data structure, the reading through of an <code>IOBuffer</code> moves the &quot;read head&quot; - in other words, there&#39;s a pointer to the end of the file after we&#39;ve read through it.</p><p>So if we run our function again:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">records </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parse_fasta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fake_file)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1-element Vector{Any}:</span></span>
<span class="line"><span> (&quot;&quot;, &quot;&quot;)</span></span></code></pre></div><p>We can see that the <code>records</code> vector only contains a Tuple with empty strings, since the loop never runs - <code>eachline(file)</code> here doesn&#39;t have any entries.</p><p>If you need to use it again, you can reset the <code>IOBuffer</code> using the <code>seekstart()</code> function:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">seekstart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fake_file)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">records </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parse_fasta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fake_file)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>3-element Vector{Any}:</span></span>
<span class="line"><span> (&quot;Rosalind_6404&quot;, &quot;CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCCTCCCACTAATAATTCTGAGG&quot;)</span></span>
<span class="line"><span> (&quot;Rosalind_5959&quot;, &quot;CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCTATATCCATTTGTCAGCAGACACGC&quot;)</span></span>
<span class="line"><span> (&quot;Rosalind_0808&quot;, &quot;CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGACTGGGAACCTGCGGGCAGTAGGTGGAAT&quot;)</span></span></code></pre></div></div><p>At this stage, we could take our <code>records</code> Vector, find the maximum gc entry, and then get that record. As with many problems, there are a lot of ways to do this, but we&#39;ll try the <code>findmax</code> function. This function takes a function as the first argument, and returns the &quot;index&quot; of the maximum value after using that function on the entry.</p><p>The &quot;index&quot; is an integer that we can use to access a particular entry in a vector or other container. In julia, the syntax for indexing is <code>container[index]</code>. And notice that, since each of our <code>records</code> are themselves containers (<code>Tuple</code>s), we can access the first element of each record (the identifier) using <code>record[1]</code>, and the second element of each record (the sequence)using <code>record[2]</code>.</p><div class="tip custom-block"><p class="custom-block-title">One-based indexing</p><p>Julia uses one-based indexing, meaning that the first element of a container is at index 1, not 0 as in some other languages like Python.</p></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> findmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(record </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(record[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]), records)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>3</span></span></code></pre></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">top_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> records[i][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># the first index gets the record, and the \`[1]\` gets the identifier</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;Rosalind_0808&quot;</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">do-block syntax</p><p>Many functions in Julia take a function as the first argument, and sometimes the <code>-&gt;</code> anonymous function syntax is a bit annoying to use. Instead, one can use the <code>do</code> block syntax. This is a way to write a more complicated anonymous function, eg one with multiple lines.</p><p>The structure of it is:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">some_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iterator) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># args is/are the argument(s) to the function</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # function body</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>In other words, our <code>findmax</code> function above could have been written as:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> findmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(records) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> record</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    gc_content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(record[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div></div><h3 id="Don&#39;t-store-the-whole-file-in-memory" tabindex="-1">Don&#39;t store the whole file in memory <a class="header-anchor" href="#Don&#39;t-store-the-whole-file-in-memory" aria-label="Permalink to &quot;Don&amp;#39;t store the whole file in memory {#Don&#39;t-store-the-whole-file-in-memory}&quot;">â€‹</a></h3><p>If you end up with a really large file, storing every record in memory, and then iterating over it a second time to calculate the GC content may not be the best approach. Instead, you can use a streaming approach, where you read the file line by line, and calculate the GC content on the fly. This way, you only need to keep one record in memory at a time, and you can find the record with the highest GC content without having to store all records in memory.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> streaming_gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current_seq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> line </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eachline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> startswith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(line, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_seq) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                current_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_seq)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_gc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    max_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_gc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    max_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_id</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> lstrip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(line, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current_seq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current_seq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> line</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_seq) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        current_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myGC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_seq)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_gc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            max_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_gc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            max_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_id</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_id</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">seekstart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fake_file)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">streaming_gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fake_file)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;Rosalind_0808&quot;</span></span></code></pre></div><h3 id="BioSequences-method-2" tabindex="-1">BioSequences method <a class="header-anchor" href="#BioSequences-method-2" aria-label="Permalink to &quot;BioSequences method {#BioSequences-method-2}&quot;">â€‹</a></h3><p>As you might imagine, parsing FASTA files is something we do all the time, so there&#39;s a package for that. In julia, that package is called <a href="https://github.com/BioJulia/FASTX.jl" target="_blank" rel="noreferrer"><code>FASTX.jl</code></a> (there&#39;s also a &quot;FASTQ&quot; file format).</p><p>This package provides FASTA &quot;readers&quot; and &quot;writers&quot;, and return iterators that validate recores and return data structures containing the sequeince identifiers and <code>BioSeqeunce</code>s.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FASTX</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fastx_gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    FASTAReader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reader </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># see the &quot;tip&quot; above about do-blocks</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> record </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reader</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> gc_content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LongDNA{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, record))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_gc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                max_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                max_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> identifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(record)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_id, max_gc</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">seekstart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fake_file)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fastx_gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fake_file)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(&quot;Rosalind_0808&quot;, 0.6091954022988506)</span></span></code></pre></div><h2 id="Reading-the-file" tabindex="-1">Reading the file <a class="header-anchor" href="#Reading-the-file" aria-label="Permalink to &quot;Reading the file {#Reading-the-file}&quot;">â€‹</a></h2><p>So far, we&#39;ve been dealing with an IOBuffer, which is what we get when we open a file. But to actually solve the rosalind problem, we need to open a file on the disk.</p><p>In julia, we do this with the <code>open</code> function, which takes a file path, and optionally a function to call with the file handle. If we don&#39;t provide a function, we get an IOBuffer just as we&#39;ve been using, but we need to be sure to close it when we&#39;re done.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> file_gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_id, max_gc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fastx_gc, filename)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(max_id)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_gc)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">file_gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;problem_inputs/rosalind_gc.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Rosalind_5466</span></span>
<span class="line"><span>51.991150442477874</span></span></code></pre></div>`,38))])}const y=l(p,[["render",o]]);export{E as __pageData,y as default};
