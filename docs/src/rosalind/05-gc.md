# üßÆ Computing GC content

!!! warning "The Problem"
    The GC-content of a DNA string is given by the percentage of symbols
    in the string that are 'C' or 'G'.
    For example, the GC-content of "AGCTATAG" is 37.5%.
    Note that the reverse complement of any DNA string has the same GC-content.

    DNA strings must be labeled when they are consolidated into a database.
    A commonly used method of string labeling is called FASTA format.
    In this format, the string is introduced by a line that begins with '>',
    followed by some labeling information.
    Subsequent lines contain the string itself;
    the first line to begin with '>' indicates the label of the next string.

    In Rosalind's implementation,
    a string in FASTA format will be labeled by the ID "Rosalind_xxxx",
    where "xxxx" denotes a four-digit code between 0000 and 9999.

    _Given_: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).

    _Return_: The ID of the string having the highest GC-content, followed by the GC-content of that string.
    Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated;
    please see the note on absolute error below.

    **Sample Dataset**
    ```
    >Rosalind_6404
    CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC
    TCCCACTAATAATTCTGAGG
    >Rosalind_5959
    CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT
    ATATCCATTTGTCAGCAGACACGC
    >Rosalind_0808
    CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC
    TGGGAACCTGCGGGCAGTAGGTGGAAT
    ```

    **Sample Output**
    ```
    Rosalind_0808
    60.919540
    ```

There are are really 3 parts of this problem.

1. Parse the input, which is in a common biological format, FASTA
2. Calculate the GC content
3. Iterate through the input, keeping track of the largest GC content.

Let's start with part 2, since it's quite similar to something we solved
[in the very first problem](@ref "üß¨ Problem 1: Counting DNA nucleotides").

## Calculating GC content

Just as when we were counting the frequency of each base,
here, we can calculate the GC content
by simply counting the number of G's or C's
and dividing that number by the total length of the sequence.

As a reminder, the `x-> do stuff` notation is an "anonymous function",
which we're using as a "predicate" for the `count()` function.
That is, `count()` will return the sum of elements where the predicate
returns `true`.

```@example gc
my_seq = "AACCGGTTCT"

function gc_content(seq)
    gcs = count(base-> base in ('G', 'C'), seq)
    return gcs / length(seq)
end

gc_content(my_seq)
```

A few things to note about this -
There's no validation of the input,
so this function will happily count the capital G's and C's
of any string:

```@example gc
gc_content("Goodbye, Cruel World!")
```

But for now, this will do.

### BioSequences method

As with many of these problems,
there is built-in functionality in the `BioSequences.jl` package.
But before we get there,
let's take a look at another problem with being permissive
in our type signature up above:

```@example gc
bioseq = LongDNA{2}(my_seq)
gc_content(bioseq)
```

What's going on here?
The definition above tries to count the `Char`s 'G' and 'C',
but when we iterate a `LongDNA`, we get back nucleotide types.
So none of them match, providing a count of ``0``.
We could modify the original function to look also for `DNA_C`,
`DNA_G`, `RNA_C`, and `RNA_G`,
or we can use the built-in predicate function `isGC()` from BioSequences,
which returns `true` if it encounters any G or C nucleotide.

```@example
function gc_content(seq::LongNuc) # this type matches LongDNA or LongRNA
    gcs = count(isGC, bioseq)
    return gcs / length(seq)
end

gc_content(bioseq)
```

## Parsing the file

We need to get this part done next.
We started talking about dealing with files in the [last problem](@ref "‚ôªÔ∏è üêá Rabbits and Recurrence Relations"),
but let's go into a bit more detail.
